package main

//MDCode Start

//MD # commentToReadme
//MD ---
//MD This is a program will create a **Readme Markdown** file from the tagged comments and code in that source file.
//MD
//MD by Dave Larsen KV0S
//MD
//MD code at <github.com/kv0s/commentToReadme>
//MD
//MD Licensed under the GPL3
//MD
//MD This README.md generated by this program.  Current testing includes golang sources.
//MD
//MD In the Release directory there are compiled executables for windows64, linux64, linux64arm (nano, odroid), linux32arm RPI
//MD
//MD To run use this commandline on our computer
//MD
//MD   > commentToReadme -filename sourcecode >README.md
//MD
//MD
//MD ---

//MDCodeEnd

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

const progname string = "commentToReadme"
const version string = "0.0.2"

// function to point users to the command list
func usage() {
	fmt.Printf("    For a list of commands use -help \n\n")
}

// Function to print the program name info
func program() {
	fmt.Printf("%s \n", progname)
	fmt.Printf("    By Dave KV0S, 2021-08-06, GPL3 \n")
}
func main() {
	// Create the command line flags
	filename := flag.String("filename", "none", "Select source file")

	flag.Parse()

	if flag.NFlag() < 1 {
		program()
		usage()
	}

	f, err := os.OpenFile(*filename, os.O_RDONLY, os.ModePerm)
	if err != nil {
		log.Fatalf("open file error: %v", err)
		return
	}
	defer f.Close()

	var codeblock bool
	codeblock = false
	rd := bufio.NewReader(f)

	for {
		line, err := rd.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}

			log.Fatalf("read file line error: %v", err)
			return
		}
		if strings.Contains(strings.TrimSpace(line), "//MDCode Start") && !strings.Contains(line, "if") { // Go, C, C++, verilog single line comment
			//fmt.Printf("%s start %v\n", strings.TrimSpace(line), codeblock)
			fmt.Printf("\n     '''\n")
			codeblock = true
		} else if strings.Contains(line, "//MDCodeEnd") && !strings.Contains(line, "if") { // Go, C, C++, verilog single line comment
			fmt.Printf("     '''\n\n")
			//fmt.Printf("%s end %v\n", strings.TrimSpace(line), codeblock)
			codeblock = false
		} else if codeblock == true {
			fmt.Printf("\t%s", line)
		} else if strings.Contains(line, "//MD") { //python single line comment
			if strings.HasPrefix(line, "//MD ") {
				fmt.Printf("%s", strings.TrimPrefix(line, "//MD "))
			} else if strings.HasPrefix(line, "//MD") {
				fmt.Printf("%s", strings.TrimPrefix(line, "//MD"))
			}
		} else if strings.Contains(line, "#MD") { //python single line comment
			if strings.HasPrefix(line, "#MD ") {
				fmt.Printf("%s", strings.TrimPrefix(line, "#MD "))
			} else if strings.HasPrefix(line, "#MD") {
				fmt.Printf("%s", strings.TrimPrefix(line, "#MD"))
			}
		} else if strings.Contains(line, "/*MD") { //Go, C, C++, verilog Start Block comment
			if strings.HasPrefix(line, "/*MD ") {
				fmt.Printf("\t%s", strings.TrimPrefix(line, "/*MD "))
			}
		} else if strings.Contains(line, "*MD ") { //Go, C, C++, verilog Continue Block comment
			if strings.HasPrefix(line, "*MD ") {
				fmt.Printf("\t%s\n", strings.TrimPrefix(line, "*MD "))
			} else if strings.HasPrefix(line, " *MD ") {
				fmt.Printf("\t%s\n", strings.TrimPrefix(line, " *MD "))
			}
		} else if strings.Contains(line, " */ ") { //Go, C, C++, verilog End Block comment

			// } else {
			// if strings.HasPrefix(line, "  ") { // pass through 2 space line
			// 	fmt.Printf("%s\n", line)
			// } else if strings.HasPrefix(line, " ") { // pass trough 1 space line
			// 	fmt.Printf("%s\n", line)
			// }

		}
	}
}

/*MD This is a block comment 1
*MD more comment 2
MD   more comment this line not passed through 3
more comment This line not passed through 4
*/
